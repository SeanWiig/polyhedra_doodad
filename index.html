<canvas id="c"></canvas>
<style>
  html, body {
    height: 100%;
    background-color: #552233;
  }
  #c {
    padding: 0;
    margin: auto;
    display: block;
    width: 50%;
    height: 50%;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
  }
</style>
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.127.0/build/three.module.js';

  function group(mesh) {
    const solid = new THREE.Mesh(
      mesh, new THREE.MeshNormalMaterial()
    );
    solid.material.transparent = true;
    //solid.material.depthTest = false;
    const wire = new THREE.Mesh(
      mesh, new THREE.MeshNormalMaterial()
    );
    wire.material.wireframe = true;
    wire.material.transparent = true;
    //wire.material.depthTest = false;
    const g = new THREE.Group();
    g.solid = solid;
    g.wire = wire;
    g.add(solid);
    g.add(wire);
    return g;
  };

  function main() {
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({canvas});
    const width = renderer.domElement.clientWidth/2;
    const height = renderer.domElement.clientHeight/2;
    renderer.setSize(width,height, false)

    const aspect = width / height;
    const camera = new THREE.PerspectiveCamera(15, aspect, 0.1, 100);
    //const camera = new THREE.OrthographicCamera(-10,10,10,-10,0.1,10);
    camera.position.z = 50;
    const scene = new THREE.Scene();
    const backcolor = new THREE.Color(0x442233);
    scene.background = backcolor;

    const octa = group(new THREE.OctahedronGeometry(1));
    const cube = group(new THREE.BoxGeometry(1,1,1));

    const rotator = new THREE.Group();
    rotator.add(cube); rotator.add(octa);
    scene.add(rotator);

    let t1 = 0;
    let t2 = 0;
    let state = 0;

    const cubeFitOffset = (Math.log(2/3) / Math.log(3));
    const scaleOffset = 1.1
    function setScale(obj, scale) {
      obj.scale.fromArray([scale,scale,scale])
    }
    function render(time) {
      time = time * 0.001;
      t1 = time * 0.2 % 1;
      t2 = (t1 + 0.5) % 1;

      setScale(cube.solid, Math.pow(3,cubeFitOffset+scaleOffset+t2-0.5));
      setScale(cube.wire, Math.pow(3,cubeFitOffset+scaleOffset+t1));
      setScale(octa.solid, Math.pow(3,scaleOffset+t1-1));
      setScale(octa.wire, Math.pow(3,scaleOffset+t2-0.5));
      
      state = t1 < 0.5
      cube.solid.renderOrder = 1+2*state
      cube.wire.renderOrder = 2+2*!state
      octa.solid.renderOrder = 1+2*!state
      octa.wire.renderOrder = 2+2*state
      
      cube.solid.material.opacity = Math.min(1,2-2*t2);
      cube.wire.material.opacity = Math.min(1,2-2*t1);
      octa.solid.material.opacity = Math.min(1,2-2*t1);
      octa.wire.material.opacity = Math.min(1,2-2*t2);

      rotator.rotation.x = time*0.5;
      rotator.rotation.y = Math.PI/4;
      rotator.rotation.z = time*0.25;

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  }

  main();
</script>
