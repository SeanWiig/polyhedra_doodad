<canvas id="c"></canvas>
<style>
  html, body {
    height: 100%;
    background-color: #332233;
  }
  #c {
    padding: 0;
    margin: auto;
    display: block;
    width: 80%;
    height: 80%;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
  }
</style>
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.127.0/build/three.module.js';

  function group(mesh) {
    const solid = new THREE.Mesh(mesh, new THREE.MeshNormalMaterial());
    solid.material.transparent = true;

    const edges = new THREE.EdgesGeometry(mesh);
    const wire = new THREE.LineSegments(edges, new THREE.LineDashedMaterial({color: 0x664455}));
    wire.material.transparent = true;
    
    const g = new THREE.Group();
    g.solid = solid;
    g.wire = wire;
    g.add(solid);
    g.add(wire);
    return g;
  };

  function main() {
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({canvas});
    const width = renderer.domElement.clientWidth/2;
    const height = renderer.domElement.clientHeight/2;
    renderer.setSize(width,height, false);

    const aspect = width / height;
    // const camera = new THREE.PerspectiveCamera(15, aspect, 0.1, 100);
    const camera = new THREE.OrthographicCamera(-7,7,7,-7,0.1,100);
    camera.position.z = 50;
    const scene = new THREE.Scene();
    const backcolor = new THREE.Color(0x442233);
    scene.background = backcolor;

    const octa = group(new THREE.OctahedronGeometry(1));
    const cube = group(new THREE.BoxGeometry(1,1,1));

    const rotator = new THREE.Group();
    rotator.add(cube); rotator.add(octa);
    scene.add(rotator);

    let t = 0;
    let t1 = 0;
    let t2 = 0;
    let state = 0;
    let tSlowStart1 = 0;
    let tSlowStart2 = 0;
    let tDelay1 = 0;
    let tDelay2 = 0;

    const cubeFitOffset = (Math.log(2/3) / Math.log(3));
    const scaleOffset = 1.3;
    function setScale(obj, scale) {
      obj.scale.fromArray([scale,scale,scale])
    };
    function render(time) {
      time = time * 0.001;
      t = time - 5;
      t1 = t * 0.2 % 1;
      t2 = (t1 + 0.5) % 1;

      setScale(cube.solid, Math.pow(3,cubeFitOffset+scaleOffset+t2-0.5));
      setScale(cube.wire, 0.99*Math.pow(3,cubeFitOffset+scaleOffset+t1));
      setScale(octa.solid, Math.pow(3,scaleOffset+t1-1));
      setScale(octa.wire, 0.99* Math.pow(3,scaleOffset+t2-0.5));
      
      state = t1 < 0.5;
      cube.solid.renderOrder = 1+2*state;
      cube.wire.renderOrder = 2+2*!state;
      octa.solid.renderOrder = 1+2*!state;
      octa.wire.renderOrder = 2+2*state;
      
      cube.solid.material.opacity = Math.min(1,2-2*t2);
      cube.wire.material.opacity = Math.min(1,2-2*t1);
      octa.solid.material.opacity = Math.min(1,2-2*t1);
      octa.wire.material.opacity = Math.min(1,2-2*t2);

      tDelay1 = Math.max(0, time - 2.5);
      tDelay2 = Math.max(0, time - 10);
      tSlowStart1 = tDelay1 / (1 + 20/tDelay1);
      tSlowStart2 = tDelay2 / (1 + 70/tDelay2);
      rotator.rotation.x = 0.9553 + tSlowStart2;
      rotator.rotation.y =  tSlowStart2/3;
      rotator.rotation.z = Math.PI/4 + tSlowStart2 / 2;
      camera.rotation.z = tSlowStart1 / (1+(tDelay1*tDelay1*0.01));

      setScale(rotator, 1-(1/(1+(time))));

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  }

  main();
</script>
